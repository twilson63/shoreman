{
  "name": "seaport",
  "description": "service registry and port assignment for clusters",
  "version": "2.0.5",
  "repository": {
    "type": "git",
    "url": "git://github.com/substack/seaport.git"
  },
  "main": "index.js",
  "browser": "lib/seaport.js",
  "bin": {
    "seaport": "bin/cmd.js"
  },
  "keywords": [
    "port",
    "allocate",
    "hub",
    "service",
    "registry",
    "roles"
  ],
  "directories": {
    "example": "example",
    "test": "test"
  },
  "scripts": {
    "test": "tap test/*.js"
  },
  "dependencies": {
    "defined": "~0.0.0",
    "indexof": "~0.0.1",
    "inherits": "~1.0.0",
    "merge": "~1.1.2",
    "object-keys": "~0.5.0",
    "optimist": "~0.3.5",
    "readable-stream": "~1.0.26",
    "secure-peer": "~0.2.1",
    "semver": "~1.1.0",
    "split": "~0.3.0",
    "stream-combiner": "~0.0.4",
    "through": "~2.3.4"
  },
  "engine": {
    "node": ">=0.8"
  },
  "devDependencies": {
    "tap": "~0.4.9",
    "destroyer": "~0.0.0"
  },
  "license": "MIT",
  "author": {
    "name": "James Halliday",
    "email": "mail@substack.net",
    "url": "http://substack.net"
  },
  "readme": "# seaport\n\nservice registry and port assignment for clusters\n\n[![build status](https://secure.travis-ci.org/substack/seaport.png)](http://travis-ci.org/substack/seaport)\n\nSeaport stores `(host,port)` combos (and other metadata) for you so you won't\nneed to spend so much effort keeping configuration files current as your\narchitecture grows to span many processes on many machines. Just register your\nservices with seaport and then query seaport to see where your services are\nrunning.\n\n![crane](http://substack.net/images/seaport.png)\n\n# example\n\n## register a service\n\nIn this example we'll register a service with seaport and then elsewhere connect\nto it.\n\nFirst spin up a seaport server:\n\n```\n$ seaport listen 9090\n```\n\nthen obtain a port for a server called `'web'`:\n\nserver.js:\n\n``` js\nvar seaport = require('seaport');\nvar ports = seaport.connect('localhost', 9090);\nvar http = require('http');\n\nvar server = http.createServer(function (req, res) {\n    res.end('beep boop\\r\\n');\n});\n\nserver.listen(ports.register('web@1.2.3'));\n```\n\nnext just `get()` that `'web'` service from another script!\n\nclient.js:\n\n``` js\nvar seaport = require('seaport');\nvar ports = seaport.connect(9090);\nvar request = require('request');\n\nports.get('web@1.2.x', function (ps) {\n    var u = 'http://' + ps[0].host + ':' + ps[0].port;\n    request(u).pipe(process.stdout);\n});\n```\n\noutput:\n\n```\n$ node server.js &\n[1] 6012\n$ node client.js\nbeep boop\n```\n\nand if you spin up `client.js` before `server.js` then it still works because\n`get()` queues the response!\n\n## http router\n\nIn this example we'll create an http router that will route to different\nversions of our application based on the http host header provided.\n\nFirst we'll create a seaport server and http proxy process, `router.js`:\n\n``` js\nvar seaport = require('seaport');\nvar server = seaport.createServer()\nserver.listen(5001);\n\nvar bouncy = require('bouncy');\nbouncy(function (req, bounce) {\n    var domains = (req.headers.host || '').split('.');\n    var service = 'http@' + ({\n        unstable : '0.1.x',\n        stable : '0.0.x'\n    }[domains[0]] || '0.0.x');\n    \n    var ps = server.query(service);\n    \n    if (ps.length === 0) {\n        var res = bounce.respond();\n        res.end('service not available\\n');\n    }\n    else {\n        bounce(ps[Math.floor(Math.random() * ps.length)]);\n    }\n}).listen(5000);\n```\n\nNow we can register different versions of the `http` process:\n\nserver_a.js:\n\n``` js\nvar seaport = require('seaport');\nvar ports = seaport.connect('localhost', 5001);\nvar http = require('http');\n\nvar server = http.createServer(function (req, res) {\n    res.end('version 0.0.0\\r\\n');\n});\n\nserver.listen(ports.register('http@0.0.0'));\n```\n\nserver_b.js:\n\n``` js\nvar seaport = require('seaport');\nvar ports = seaport.connect('localhost', 5001);\nvar http = require('http');\n\nvar server = http.createServer(function (req, res) {\n    res.end('version 0.1.0\\r\\n');\n});\n\nserver.listen(ports.register('http@0.1.0'));\n```\n\nNow once all these processes are running, we can query the http proxy and get\nback different versions of our service:\n\n```\n$ curl -H 'Host: stable' localhost:5000\nversion 0.0.0\n$ curl -H 'Host: unstable' localhost:5000\nversion 0.1.0\n```\n\n## authorized keys\n\nFor security you can sign messages and maintain a list of authorized public keys\nwhich are allowed to register services and make updates.\n\nFirst make some PEM keypairs with\n[rsa-json](http://github.com/substack/rsa-json):\n\n```\n$ mkdir keys\n$ rsa-json > keys/hub.json\n$ rsa-json > keys/web.json\n```\n\nNow we can create a seaport with an authorized keys list:\n\n``` js\nvar fs = require('fs');\nvar publicKeys = fs.readdirSync(__dirname + '/keys')\n    .filter(function (x) { return /\\.json$/.test(x) })\n    .map(function (x) { return require('./keys/' + x).public })\n;\nvar seaport = require('seaport');\n\nvar opts = require('./keys/hub.json');\nopts.authorized = publicKeys;\n\nvar ports = seaport.createServer(opts);\nports.listen(9090);\n```\n\nNow we can register a server with an authorized key:\n\n``` js\nvar seaport = require('seaport');\nvar ports = seaport.connect(9090, require('./keys/web.json'));\n\nvar http = require('http');\nvar server = http.createServer(function (req, res) {\n    res.end('beep boop\\n');\n});\nserver.listen(ports.register('web@1.2.3'));\n```\n\nNo credentials are required to query the entries, only to register and update\nentries. Our client can just query seaport directly:\n\n``` js\nvar seaport = require('seaport');\nvar ports = seaport.connect(9090);\nvar request = require('request');\n\nports.get('web@1.2.x', function (ps) {\n    var u = 'http://' + ps[0].host + ':' + ps[0].port;\n    var r = request(u);\n    \n    r.pipe(process.stdout);\n    r.on('end', ports.close.bind(ports));\n});\n```\n\n***\n\n```\n$ node client.js\nbeep boop\n```\n\n# methods\n\n```\nvar seaport = require('seaport')\n```\n\nAll the parameters that take a `role` parameter can be intelligently versioned\nwith [semvers](https://github.com/isaacs/node-semver) by specifying a version in\nthe `role` parameter after an `'@'` character.\n\n## var s = seaport(opts)\n\nCreate a new seaport instance.\n\nTo sign your messages, specify `opts.private` and `opts.public` as PEM-encoded\nstrings.\n\nTo set an initial list of authorized keys which are allowed to make updates,\npass `opts.authorized` as an array of PEM-encoded public key strings.\n\nWhen the authorized key list is empty, all connected nodes may make updates.\n\nConsider using [rsa-json](https://github.com/substack/rsa-json) to generate\nthe keypairs.\n\n## var s = seaport.connect(..., opts)\n\nCreate a seaport instance piped to a tcp connection at `...`.\n\nIf the server at `...` is not available or the connection drops, the connection\nis retried every second. If the seaport server is down, other hubs that\nregistered themselves with the role `'seaport'` are tried in a round-robin.\n\n## var s = seaport.createServer(opts)\n\nCreate a seaport instance with an attached tcp server with `.listen()` and\n`.address()` methods that will set up streams in \"server mode\" for incoming tcp\nconnections.\n\nInternally seaport uses a heartbeat to help identify stale or orphaned service\nregistrations. Use `opts.heartbeatInterval`, in milliseconds, to set the interval\nthat clients should update their heartbeat. The default heartbeatInterval is `60000`.\n\n## s.createStream(host)\n\nCreate a duplex stream of the underlying\n[crdt](https://github.com/dominictarr/crdt) object.\n\nIf `host` is specified, seaport goes into \"server mode\" where it stores the\n`host` value on the network for the remote endpoint's node id.\n\n## var port = s.register(role, opts)\n\nRegister the service described by the string `role`\n(name@verion, version optional). Return the port to use for the service.\n\nRegistrations are valid so long as the connection to the seaport server is still\nalive. When the connection to the seaport server goes down, all registrations\nare freed.\n\nYou can optionally store whatever other records you want on the service by\nputting those keys in `opts`.\n\nIf `opts.port` is specified, return and store that value for the service port.\nOtherwise a random available port is chosen. If you want to specify a valid\nrange for ports to be, set `opts.range` (default: `[ 10000, 65535 ]`).\n\nIf you don't want you specify `role` you can also use `opts.role` and\n`opts.version`.\n\nYou can control what the key name will be by setting `opts.id` yourself.\nOtherwise a random hex string will be used.\n\n## var meta = s.registerMeta(role, opts)\n\nLike `s.register()`, but return the entire meta object instead of just the\n`meta.port`. This is handy if you need the `id` to update metadata later.\n\n## var services = s.query(search)\n\nQuery the seaport entries with `search` as a `name@semver` string.\nThe `@semver` part is optional and all the usual semver pattern matching\napplies.\n\nReturns an array of all the matching services for `search`.\n\nIf `search` is `undefined`, all the records are returned.\n\n## s.get(role, cb)\n\nLike `.query()`, but does `cb(services)` with the list of matching entries.\nIf `services` is empty, `cb` won't fire until there is at least one match\navailable.\n\n## s.free(service), s.free(id)\n\nRemove a service registered with `.register()`. You can remove a service by the\n`service` object itself or just its `id`.\n\n## s.authorize(publicKey)\n\nAuthorize the PEM-encoded `publicKey` string to make updates.\nUpdates include registering services and setting keys.\n\n## s.close()\n\nClose a seaport connection or server. Cancel any pending requests.\n\n## s.set(id, value)\n\nUpdate a registration value by its `id`, broadcasting the new registration meta\n`value`.\n\n# events\n\n## s.on('register', function (service) {})\n\nEmitted whenever any node registers a new service.\n\n## s.on('free', function (service) {})\n\nEmitted whenever any node frees a service that was previously registered.\n\n## s.on('host', function (host) {})\n\nIn non-server mode, the client will receive notification from the server what\nits `host` is on the network.\n\n## s.on('reject', function (key, value, timestamp, source, sig) {})\n\nEmitted when key signing fails or when a node tries to send update but is not in\nthe authorized key list.\n\n## s.on('connect', function () {})\n\nEmitted when a connection is established with `seaport.connect()`.\n\n## s.on('disconnect', function () {})\n\nEmitted when a connection established by `seaport.connect()` drops.\n\n## s.on('close', function () {})\n\nThe `'close'` event fires when `s.close()` is called.\n\n## s.on('timeout', function () {})\n\nWhen the connection times out, this event fires.\n\n# command-line usage\n\n```\nusage:\n\n  seaport listen PORT [KEY.json, ...]\n\n    Create a seaport server on PORT.\n    Optionally load authorized public keys from json files.\n    \n    Key files of arrays are expected to be PEM public key lists.\n    Key files are otherwise expected to have public and private fields.\n\n  seaport show HOST:PORT\n\n    Show the seaport records for the server running at HOST:PORT.\n \n  seaport watch HOST:PORT\n\n    Listen for register and free events from the seaport registry.\n    For even more output use `-v` or `--verbose`.\n\n  seaport query HOST:PORT PATTERN\n\n    Run a query for PATTERN against the server running at HOST:PORT.\n\n  seaport register HOST:PORT NAME@VERSION {OPTIONS} -- [COMMAND...]\n\n    Register a service. COMMAND will get an assigned port to use as\n    its last argument. If COMMAND exits it will be restarted.\n    \n    OPTIONS:\n    \n    --key=key.json    Load a public/private PEM keypair from key.json.\n    --meta.KEY=...    Set json metadata on the service record.\n \n```\n\n# install\n\nTo get the seaport library, with [npm](http://npmjs.org) do:\n\n```\nnpm install seaport\n```\n\nTo get the seaport command, do:\n\n```\nnpm install -g seaport\n```\n\n# license\n\nMIT\n",
  "readmeFilename": "readme.markdown",
  "bugs": {
    "url": "https://github.com/substack/seaport/issues"
  },
  "homepage": "https://github.com/substack/seaport",
  "_id": "seaport@2.0.5",
  "_from": "seaport@"
}
